import React, { useEffect, useState } from 'react';
import { Resolver } from '@stoplight/json-ref-resolver';
import Admonition from '@theme/Admonition';
import Heading from '@theme/Heading';
import Details from '@theme/Details';
import ReactMarkdown from 'react-markdown';
import JSONSchema from '../../../static/nebari-config-schema.json'
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

const schemaUrl = "https://raw.githubusercontent.com/viniciusdc/nebari/nebari-schema-models/nebari-config-schema.json";

type SchemaProperty = {
    deprecated?: boolean;
    description?: string;
    type?: string | string[];
    pattern?: string;
    title?: string;
    items?: any;
    properties?: { [key: string]: SchemaProperty };
    enum?: string[];
    default?: any;
    allOf?: SchemaProperty[];
    examples?: string[];
    optionsAre?: string[];
};

type Properties = { [key: string]: SchemaProperty };

type Schema = {
    title: string;
    description: string;
    type: string;
    properties: Properties;
    required?: string[];
};

const defaultSchema: Schema = {
    title: "ConfigSchema",
    description: "The configuration schema for Nebari.",
    type: "object",
    properties: {}
};

function useSchema(schemaUrl: string, useLocal = false) {
    const [schema, setSchema] = useState<Schema>(defaultSchema);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        if (useLocal) {
            setSchema(JSON.parse(JSON.stringify(JSONSchema)));
            setLoading(false);
            setError(null);
        } else {
            async function fetchSchema() {
                try {
                    const response = await fetch(schemaUrl, { headers: { 'Accept': 'application/json' } });
                    if (!response.ok) {
                        throw new Error(`Failed to fetch schema: ${response.status} ${response.statusText}`);
                    }

                    const json = await response.json();
                    const resolver = new Resolver();
                    const resolvedSchema = await resolver.resolve(json, {});
                    setSchema(resolvedSchema.result);
                } catch (err) {
                    console.error('Error:', err);
                    setError(err.message);
                } finally {
                    setLoading(false);
                }
            }

            fetchSchema();
        }
    }, [schemaUrl, useLocal]);  // Added useLocal as a dependency

    return { schema, loading, error };
}

export default function NebariConfig() {
    const { schema, loading, error } = useSchema(schemaUrl, true);

    if (loading) return <p>Loading schema...</p>;
    if (error) return <p>Error loading schema: {error}</p>;

    return (
        <>
            <Admonition type="info">
                This documentation is autogenerated from the Nebari configuration JSON Schema.
                <a href={schemaUrl} target="_blank" rel="noopener noreferrer">View the original schema</a>.
            </Admonition>
            <Markdown text={schema.description} />
            <PropertiesList properties={schema.properties} />
        </>
    );
}

function PropertiesList({ properties }: { properties: Properties }) {
    return (
        <>
            {Object.entries(properties).map(([key, value]) => (
                <PropertyDetail key={key} name={key} property={value} />
            ))}
        </>
    );
}

function PropertyDetail({ name, property }: { name: string; property: SchemaProperty }) {
    const hasNestedProperties = property.properties && Object.keys(property.properties).length > 0;
    const shouldUseDetails = (property.allOf && hasNestedProperties) || hasNestedProperties;

    const mergedProperty = shouldUseDetails ? mergeAllOf(property) : property;

    return shouldUseDetails ? (
        <Details open>
            <Heading as="h2" id={name.replace(/_/g, "-")}>
                {mergedProperty.title || name}
            </Heading>
            <PropertyContent property={mergedProperty} />
            {mergedProperty.properties && <PropertiesList properties={mergedProperty.properties} />}
        </Details>
    ) : (
        <>
            <Heading as="h2" id={name.replace(/_/g, "-")}>
                {property.title || name}
            </Heading>
            <PropertyContent property={property} />
            {hasNestedProperties && <PropertiesList properties={property.properties} />}
        </>
    );
}

const MarkdownCodeSeparator = ({ examples, inputKey }) => {
    // Function to extract the YAML code block and briefing paragraph from each example
    const parseContent = (input) => {
        const codeRegex = /```yaml[\s\S]*?```/;  // Regex to match the YAML code block
        const codeMatch = input.match(codeRegex);

        let codeBlock = '';
        if (codeMatch) {
            // Extract code and remove the fencing
            codeBlock = codeMatch[0].replace(/```yaml|```/g, '').trim();
            // Normalize indentation
            const lines = codeBlock.split('\n');
            const minIndentation = lines.filter(line => line.trim())
                .reduce((min, line) => Math.min(min, line.search(/\S/)), Infinity);
            codeBlock = lines.map(line => line.substring(minIndentation)).join('\n');
        }

        const briefing = input.replace(codeRegex, '').trim();  // Remove the code block from the briefing

        return { briefing, codeBlock };
    };

    // Check if examples is defined and is an array
    if (!Array.isArray(examples)) {
        return <div>No examples provided</div>;
    }

    if (examples.length > 1) {
        // Render content inside tabs when there are multiple examples
        return (
            <Tabs defaultValue="example-0" values={examples.map((_, index) => ({ label: `Example ${index + 1}`, value: `example-${index}` }))}>
                {examples.map((example, index) => {
                    const { briefing, codeBlock } = parseContent(example); // Correct placement
                    return (
                        <TabItem key={index} value={`example-${index}`}>
                            <div>
                                <ReactMarkdown>{briefing}</ReactMarkdown>
                                <pre style={{ borderRadius: '8px', border: '1px solid #ccc', padding: '10px', overflow: 'auto' }}>
                                    {codeBlock}
                                </pre>
                            </div>
                        </TabItem>
                    );
                })}
            </Tabs>
        );
    } else {
        // If only one example, no need for tabs
        const { briefing, codeBlock } = parseContent(examples[0]);
        return (
            <div key={inputKey}>
                <ReactMarkdown>{briefing}</ReactMarkdown>
                <pre style={{ borderRadius: '8px', border: '1px solid #ccc', padding: '10px', overflow: 'auto' }}>
                    {codeBlock}
                </pre>
            </div>
        );
    }
};

function PropertyContent({ property }: { property: SchemaProperty }) {
    return (
        <>
            {property.description && <ReactMarkdown>{property.description}</ReactMarkdown>}
            {property.type && <p>Type: {Array.isArray(property.type) ? property.type.join(", ") : property.type}</p>}
            {property.default !== undefined && <p>Default: {JSON.stringify(property.default)}</p>}
            {property.enum && <p>Available options: {property.enum.join(", ")}</p>}
            {property.optionsAre && <p>Options: {property.optionsAre.join(", ")}</p>}
            {property.pattern && <p>Pattern: {property.pattern}</p>}
            {property.examples && <MarkdownCodeSeparator examples={property.examples} inputKey="examples" />}
            {property.deprecated && <p><span className="badge badge--danger">Deprecated</span></p>}

        </>
    );
}

function mergeAllOf(property: SchemaProperty): SchemaProperty {
    if (!property.allOf) return property;
    const base = { ...property, allOf: undefined };
    return property.allOf.reduce((acc, cur) => {
        return {
            ...acc,
            ...mergeAllOf(cur),
            properties: { ...acc.properties, ...cur.properties },
        };
    }, base);
}

const Markdown = ({ text }: { text: string }) => <ReactMarkdown>{text}</ReactMarkdown>;
