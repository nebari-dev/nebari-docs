import React, { useState, useEffect } from "react";
import ReactMarkdown from "react-markdown";
import remarkGfm from "remark-gfm";
import { Resolver } from "@stoplight/json-ref-resolver";

import Details from "@theme/Details";
import Admonition from "@theme/Admonition";
import Heading from "@theme/Heading";

// Schema Initial Data
const NebariSchema = {
    title: "Nebari Configuration Schema",
    description: "The Nebari configuration schema.",
    type: "object",
    properties: {
        name: {
            type: "string",
            description: "The name of the package.",
            examples: ["nebari"],
        },
        description: {
            type: "string",
            description: "The description of the package.",
            examples: ["A package manager for conda packages."],
        },
    },
};

// Main Component
export default function NebariJsonSchema({ toc = null }) {
    const schemaURL = "https://raw.githubusercontent.com/viniciusdc/nebari/nebari-schema-models/nebari-config-schema.json";
    const [schema, setSchema] = useState(NebariSchema);
    const [resolved, setResolved] = useState(false);

    useEffect(() => {
        const fetchSchema = async () => {
            try {
                const response = await fetch(schemaURL, { headers: { Accept: "application/json" } });
                const rawSchema = await response.json();
                const resolver = new Resolver();
                const resolvedSchema = await resolver.resolve(rawSchema);
                setSchema(resolvedSchema.result);
                setResolved(true);
            } catch (error) {
                console.error('Failed to fetch and resolve schema', error);
            }
        };
        fetchSchema();
    }, []);

    return (
        <>
            <Admonition type="info">
                This documentation is autogenerated from{" "}
                <a href={schemaURL} target="_blank">
                    Nebari config yaml's JSON Schema
                </a>.
            </Admonition>
            <SchemaToc schema={schema} />
            <ReactMarkdown remarkPlugins={[remarkGfm]}>{schema.description}</ReactMarkdown>
            <p></p>
            {schema.properties && Object.entries(schema.properties).sort().map(([key, value]) => (
                <Setting key={key} name={key} value={value} withTypes={resolved} toc={toc} />
            ))}
        </>
    );
}

// Sub-Components
function SchemaToc({ schema }) {
    return (
        <ul>
            {Object.entries(schema.properties).sort().map(([key, value]) => (
                <li key={key}>
                    <a href={`#${key.replace(/_/g, "-")}`}>
                        {value.deprecated ? <span style={{ textDecoration: "line-through" }}>{key}</span> : key}
                    </a>
                </li>
            ))}
        </ul>
    );
}

function Setting({ name, value, withTypes = true, toc = null }) {
    if (toc) {
        toc.push({ value: name, id: name.replace(/_/g, "-"), level: 3 });
    }

    return (
        <>
            <a id={name.replace(/_/g, "-")}></a>
            <Heading as={`h3`}>{value.deprecated ? <span style={{ textDecoration: "line-through" }}>{name}</span> : name}</Heading>
            {value.deprecated && (
                <p>
                    <span className={["badge", "badge--danger"].join(" ")}>
                        Deprecated
                    </span>
                </p>
            )}
            {value.description && <ReactMarkdown remarkPlugins={[remarkGfm]}>{value.description.trim()}</ReactMarkdown>}
            {withTypes && <Type value={value} />}
            {value.examples && (
                <Details summary="Examples" closed>
                    <ReactMarkdown remarkPlugins={[remarkGfm]}>{value.examples.join(", ")}</ReactMarkdown>
                </Details>
            )}
        </>
    );
}

function Type({ value }) {
    const types = [];
    const customTypes = { options: [] };

    value.anyOf?.forEach(v => {
        if (v.type) {
            types.push(<code key={v.type}>{v.type}</code>);
            if (v.enum) {
                customTypes.options.push(...v.enum.map(e => <code key={e}>{e}</code>));
            }
        }
    });

    return (
        <>
            {types.length > 0 && <span>Type: {types.reduce((prev, curr) => [prev, ', ', curr])}</span>}
            {value.default !== undefined && <span> Default: <code>{JSON.stringify(value.default)}</code></span>}
            {customTypes.options.length > 0 && (
                <>
                    <br />
                    <span>Options: {customTypes.options}</span>
                </>
            )}
        </>
    );
}
